<template>
  <div class="page-container">
    <!-- Header Âõ∫ÂÆöÁΩÆÈ°∂ÔºåË¶ÜÁõñÂÖ®Â±è -->
    <Header />
    
    <!-- ‰∏ªÂÜÖÂÆπÂå∫Âüü -->
    <div class="mockup-tool-container">
      <div class="unified-content-container">
        <!-- Ê†áÈ¢òÂå∫Âüü -->
        <div class="header-section">
          <PageHeader title="Book Mockup Generator Tool" />
        </div>

        <!-- ÂäüËÉΩÂå∫Âüü -->
        <div class="function-section">
          <!-- Ê∏≤ÊüìÁªìÊûú (ÁßªÂà∞Â∑¶Ëæπ) -->
          <div class="result-panel">
            <div ref="canvasContainer" class="canvas-container">
              <canvas ref="mockupCanvas"></canvas>
            </div>
            
            <!-- Êñ∞Â¢ûÔºö‰ø°ÊÅØÊ®°Âùó -->
            <div class="info-panel">
              <div class="info-tags">
                <span class="tag">front</span>
                <span class="tag-separator">|</span>
                <span class="tag">book</span>
                <span class="tag-separator">|</span>
                <span class="tag">hardcover book</span>
                <span class="tag-separator">|</span>
                <span class="tag">book mockup</span>
                <span class="tag-separator">|</span>
                <span class="tag">hardcover</span>
                <span class="tag-separator">|</span>
                <span class="tag">hardcover book mockup</span>
                <span class="tag-separator">|</span>
                <span class="tag">book mockup generator</span>
              </div>
              
              <div class="info-description">
                This charming mockup template features a small child sitting among friends, holding a book cover in their hands.
              </div>
              
              <div class="info-template">
                <div class="template-item">
                  <span class="template-label">Published:</span>
                  <span class="template-value">24 Jun 2024</span>
                </div>
                <div class="template-item">
                  <span class="template-label">Size:</span>
                  <span class="template-value">1024x1024px</span>
                </div>
              </div>
            </div>
          </div>



          <!-- ÊéßÂà∂Èù¢Êùø (ÁßªÂà∞Âè≥Ëæπ) -->
          <div class="control-panel">
            <div class="panel-header">
              <span class="panel-title">Edit this template</span>
              <el-button style="float: right; padding: 3px 0" type="text">Download PSD</el-button>
            </div>

            <div class="control-group">
              <div class="format-selector">
                <el-radio-group v-model="format" size="small">
                  <el-radio-button label="JPEG"></el-radio-button>
                  <el-radio-button label="PNG"></el-radio-button>
                </el-radio-group>
              </div>
              <el-button type="primary" class="upgrade-btn">Upgrade to Download</el-button>
            </div>

            <el-divider></el-divider>

            <div class="control-item">
              <span class="label">Highlights</span>
              <el-switch v-model="highlights" active-color="#13ce66"></el-switch>
            </div>

            <div class="control-item">
              <span class="label">Shadows</span>
              <el-switch v-model="shadows" active-color="#13ce66"></el-switch>
            </div>

            <el-divider></el-divider>

            <div class="image-control">
              <div class="control-item">
                <span class="label">Your image:</span>
                <el-switch v-model="coverEnabled" active-color="#13ce66"></el-switch>
              </div>
              <span class="image-size">512x636px</span>
              <el-upload
                class="image-uploader"
                action="#"
                :auto-upload="false"
                :show-file-list="false"
                :on-change="handleImageUpload"
                accept="image/*"
              >
                <el-button class="upload-action-btn" type="danger" icon="el-icon-picture-outline">
                  Add image/design
                </el-button>
              </el-upload>
              <img
                ref="previewImage"
                class="preview-image"
                alt="‰∏ä‰º†ÂõæÁâáÈ¢ÑËßà"
              />
            </div>
                         <el-divider></el-divider>

             <div class="render-section" style="margin-top: 1rem;">
               <el-button
                 type="primary"
                 @click="handleRender"
                 :loading="isLoading"
                 :disabled="!userImage"
                 class="render-button"
               >
                 {{ isLoading ? 'Ê≠£Âú®Ê∏≤Êüì...' : '2. Ê∏≤ÊüìÂ∞ÅÈù¢ÔºàÊô∫ËÉΩÂêàÊàêÊâãÈÉ®ÈÅÆÁΩ©Ôºâ' }}
               </el-button>
             </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
// „ÄêÈáçË¶Å„ÄëËøôÊòØÂú®VueÈ°πÁõÆ‰∏≠ÂºïÂÖ•ÂõæÁâáÁöÑÊ†áÂáÜÊñπÂºè
import bookBackground1 from '@/assets/images/book-background1.jpg';
import bookHighlights1 from '@/assets/images/book-highlights1.png';
import bookMask1 from '@/assets/images/book-mask1.png';

export default {
  name: 'MockupTool',
  components: {
    Header: () => import('@/components/Header.vue'),
    PageHeader: () => import('@/components/PageHeader.vue')
  },
  data() {
    return {
      userImage: null, // Â≠òÂÇ®Áî®Êà∑‰∏ä‰º†ÁöÑÂõæÁâáÂØπË±°
      isLoading: false,
      // Êñ∞Â¢ûÁöÑÊéßÂà∂ÈÄâÈ°π
      format: 'PNG',
      highlights: true,
      shadows: true,
      coverEnabled: true,
      colorEnabled: true,
      selectedColor: '#FFFFFF',
      backgroundEnabled: true,
      backgroundFormat: 'PNG',
      // Ê®°ÊùøÊï∞ÊçÆÁé∞Âú®Áõ¥Êé•ÂÆö‰πâÂú®ÁªÑ‰ª∂ÂÜÖÈÉ®
      template: {
        id: 'child-book',
        width: 800,
        height: 600,
        layers: [
          { type: 'image', src: bookBackground1, id: 'background' },
          {
            type: 'transformed-image',
            name: 'cover',
            destPoints: [
            { x: 252, y: 136 }, // Â∑¶‰∏äÔºöÂêëÂè≥ÁßªÂä®100px
              { x: 548, y: 134 }, // Âè≥‰∏äÔºöÂêëÂè≥ÁßªÂä®100px
              { x: 550, y: 495 }, // Âè≥‰∏ãÔºöÂêëÂè≥ÁßªÂä®100px
              { x: 260, y: 503 }, // Â∑¶‰∏ãÔºöÂêëÂè≥ÁßªÂä®100px
            ],
          },
          { type: 'image', src: bookHighlights1, id: 'highlights' },
          { type: 'image', src: bookMask1, id: 'mask' },
        ],
      },
    };
  },
  mounted() {
    // Á≠âÂæÖDOMÂÆåÂÖ®Ê∏≤ÊüìÂêéÂÜçÂàùÂßãÂåñ
    this.$nextTick(() => {
      console.log('DOMÂ∑≤Ê∏≤ÊüìÂÆåÊàêÔºåÂºÄÂßãÊòæÁ§∫ËÉåÊôØÂõæ');
      // Âª∂Ëøü‰∏ÄÁÇπÊó∂Èó¥Á°Æ‰øùCanvasÂÆåÂÖ®ÂáÜÂ§áÂ•Ω
      setTimeout(() => {
        this.showBackgroundOnly();
      }, 100);
    });
    window.addEventListener('resize', this.handleResize);
    
    // Ê∑ªÂä†Ë∞ÉËØïÂáΩÊï∞Âà∞ÂÖ®Â±ÄÔºåÊñπ‰æøÊµãËØïÂùêÊ†á
    window.testCoordinates = () => {
      console.log('üîç ÂΩìÂâçÂùêÊ†áÈÖçÁΩÆ:');
      console.log('Ê®°ÊùøÂ±ÇÊï∞:', this.template.layers.length);
      console.log('Â∞ÅÈù¢Â±ÇÁ¥¢Âºï:', this.template.layers.findIndex(l => l.type === 'transformed-image'));
      
      const coverLayer = this.template.layers.find(l => l.type === 'transformed-image');
      if (coverLayer) {
        console.log('Â∞ÅÈù¢Â±Ç:', coverLayer);
        console.log('destPointsÈïøÂ∫¶:', coverLayer.destPoints.length);
        console.log('Â∑¶‰∏ä:', coverLayer.destPoints[0]);
        console.log('Âè≥‰∏ä:', coverLayer.destPoints[1]);
        console.log('Âè≥‰∏ã:', coverLayer.destPoints[2]);
        console.log('Â∑¶‰∏ã:', coverLayer.destPoints[3]);
        
        // ÊµãËØïÂùêÊ†áËÆøÈóÆ
        console.log('üîç ÂùêÊ†áËÆøÈóÆÊµãËØï:');
        coverLayer.destPoints.forEach((point, index) => {
          const x = point.x || (point._value && point._value.x) || 0;
          const y = point.y || (point._value && point._value.y) || 0;
          console.log(`ÁÇπ${index}: x=${x}, y=${y}`);
        });
      } else {
        console.log('‚ùå Êú™ÊâæÂà∞Â∞ÅÈù¢Â±Ç');
      }
      console.log('üîç ÊµãËØïÂÆåÊàê');
    };
    
    // Ê∑ªÂä†ÊµãËØïÂõõËæπÂΩ¢ÁªòÂà∂ÁöÑÂáΩÊï∞
    window.testQuadrilateral = () => {
      const canvas = this.$refs.mockupCanvas;
      if (!canvas) {
        console.log('‚ùå CanvasÊú™ÊâæÂà∞');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      const scale = canvas.width / this.template.width;
      
      const coverLayer = this.template.layers.find(l => l.type === 'transformed-image');
      if (!coverLayer) {
        console.log('‚ùå Â∞ÅÈù¢Â±ÇÊú™ÊâæÂà∞');
        return;
      }
      
      const dest = coverLayer.destPoints.map(p => {
        const x = p.x || (p._value && p._value.x) || 0;
        const y = p.y || (p._value && p._value.y) || 0;
        return { x: x * scale, y: y * scale };
      });
      
      console.log('üîç ÊµãËØïÂõõËæπÂΩ¢ÁªòÂà∂:');
      console.log('Áº©ÊîæÂêéÂùêÊ†á:', dest);
      
      // ÁªòÂà∂ÊµãËØïÂõõËæπÂΩ¢
      ctx.save();
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 3;
      
      ctx.beginPath();
      ctx.moveTo(dest[0].x, dest[0].y);
      ctx.lineTo(dest[1].x, dest[1].y);
      ctx.lineTo(dest[2].x, dest[2].y);
      ctx.lineTo(dest[3].x, dest[3].y);
      ctx.closePath();
      
      ctx.stroke();
      ctx.restore();
      
      console.log('üîç ËìùËâ≤ÊµãËØïÂõõËæπÂΩ¢ÁªòÂà∂ÂÆåÊàê');
    };
    
    console.log('üí° Ë∞ÉËØïÊèêÁ§∫: Âú®ÊéßÂà∂Âè∞ËæìÂÖ• testCoordinates() ÂèØ‰ª•Êü•ÁúãÂΩìÂâçÂùêÊ†á');
  },
  beforeDestroy() {
    window.removeEventListener('resize', this.handleResize);
  },
  methods: {
    handleResize() {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = setTimeout(() => {
        this.renderMockup(this.userImage);
      }, 200);
    },

    handleImageUpload(file) {
      if (file.raw) {
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            this.userImage = await this.loadImage(e.target.result);
            this.$refs.previewImage.src = e.target.result;
            this.$refs.previewImage.style.display = 'block';
          } catch (error) {
            this.$message.error('Âä†ËΩΩÈ¢ÑËßàÂõæÁâáÂ§±Ë¥•ÔºÅ');
            console.error(error);
          }
        };
        reader.readAsDataURL(file.raw);
      }
    },

    handleRender() {
      if (!this.userImage) {
        this.$message.warning('ËØ∑ÂÖà‰∏ä‰º†‰∏ÄÂº†Â∞ÅÈù¢ÂõæÁâáÔºÅ');
        return;
      }
      // Ëá™Âä®ÊâßË°åÊô∫ËÉΩÂêàÊàêÊµÅÁ®ãÔºöÂÖàÂêàÊàêÊâãÈÉ®ÈÅÆÁΩ©ÔºåÂÜçËøõË°å‰π¶Êú¨Ê∏≤Êüì
      this.renderWithSmartMerge();
    },

    // Êô∫ËÉΩÊ∏≤ÊüìÔºöËá™Âä®ÂêàÊàêÊâãÈÉ®ÈÅÆÁΩ©ÔºåÂÜçËøõË°å‰π¶Êú¨Ê∏≤Êüì
    async renderWithSmartMerge() {
      this.isLoading = true;
      
      try {
        console.log('=== ÂºÄÂßãÊô∫ËÉΩÊ∏≤ÊüìÊµÅÁ®ã ===');
        
        // Á¨¨‰∏ÄÊ≠•ÔºöÂêàÊàêÁî®Êà∑ÂõæÁâá‰∏éÊâãÈÉ®ÈÅÆÁΩ©
        const mergedUserImage = await this.mergeUserImageWithHandMask(this.userImage);
        
        if (!mergedUserImage) {
          this.$message.error('ÂõæÁâáÂêàÊàêÂ§±Ë¥•ÔºåËØ∑ÈáçËØïÔºÅ');
          return;
        }
        
        // Á¨¨‰∫åÊ≠•Ôºö‰ΩøÁî®ÂêàÊàêÂêéÁöÑÂõæÁâáËøõË°å‰π¶Êú¨Ê∏≤Êüì
        await this.renderMockupWithMergedImage(mergedUserImage);
        
        console.log('=== Êô∫ËÉΩÊ∏≤ÊüìÂÆåÊàê ===');
        
      } catch (error) {
        console.error('Êô∫ËÉΩÊ∏≤ÊüìËøáÁ®ã‰∏≠Âá∫Èîô:', error);
        this.$message.error('Ê∏≤ÊüìÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞„ÄÇ');
      } finally {
        this.isLoading = false;
      }
    },

    loadImage(src) {
      return new Promise((resolve, reject) => {
        console.log('ÂºÄÂßãÂä†ËΩΩÂõæÁâá:', src);
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        
        img.onload = () => {
          console.log('ÂõæÁâáÂä†ËΩΩÊàêÂäü:', src, 'Â∞∫ÂØ∏:', img.width, 'x', img.height);
          resolve(img);
        };
        
        img.onerror = (err) => {
          console.error('ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•:', src, err);
          reject(`ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•: ${src}, ${err}`);
        };
        
        img.src = src;
      });
    },

    adjustCanvasSize(canvas) {
      const container = this.$refs.canvasContainer;
      if (!container) return;
      const containerWidth = container.clientWidth;
      const aspectRatio = this.template.width / this.template.height;
      canvas.width = containerWidth;
      canvas.height = containerWidth / aspectRatio;
    },

    // ÊòæÁ§∫ËÉåÊôØÂõæÔºàÈ°µÈù¢ÂàùÂßãÂåñÊó∂‰ΩøÁî®Ôºâ
    async showBackgroundOnly() {
      const canvas = this.$refs.mockupCanvas;
      if (!canvas) {
        console.error('CanvasÊú™ÊâæÂà∞');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Êó†Ê≥ïËé∑ÂèñCanvas‰∏ä‰∏ãÊñá');
        return;
      }

      try {
        console.log('ÂºÄÂßãÊòæÁ§∫ËÉåÊôØÂõæ');
        
        // Ë∞ÉÊï¥CanvasÂ∞∫ÂØ∏
        this.adjustCanvasSize(canvas);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Âè™Âä†ËΩΩÂπ∂ÊòæÁ§∫ËÉåÊôØÂõæ
        const backgroundLayer = this.template.layers.find(l => l.id === 'background');
        if (backgroundLayer) {
          console.log('Âä†ËΩΩËÉåÊôØÂõæÁâá:', backgroundLayer.src);
          const backgroundImg = await this.loadImage(backgroundLayer.src);
          
          // ‰øÆÂ§çÔºö‰øùÊåÅËÉåÊôØÂõæÂéüÂßãÂÆΩÈ´òÊØîÔºåËá™ÈÄÇÂ∫îÊòæÁ§∫
          const bgAspectRatio = backgroundImg.width / backgroundImg.height;
          const canvasAspectRatio = canvas.width / canvas.height;
          
          let bgWidth, bgHeight, bgX, bgY;
          
          if (canvasAspectRatio > bgAspectRatio) {
            // CanvasÊõ¥ÂÆΩÔºå‰ª•È´òÂ∫¶‰∏∫ÂáÜ
            bgHeight = canvas.height;
            bgWidth = bgHeight * bgAspectRatio;
            bgX = (canvas.width - bgWidth) / 2;
            bgY = 0;
          } else {
            // CanvasÊõ¥È´òÔºå‰ª•ÂÆΩÂ∫¶‰∏∫ÂáÜ
            bgWidth = canvas.width;
            bgHeight = bgWidth / bgAspectRatio;
            bgX = 0;
            bgY = (canvas.height - bgHeight) / 2;
          }
          
          console.log('ËÉåÊôØÂõæËá™ÈÄÇÂ∫îÂèÇÊï∞:', { bgWidth, bgHeight, bgX, bgY });
          ctx.drawImage(backgroundImg, bgX, bgY, bgWidth, bgHeight);
          console.log('‚úì ËÉåÊôØÂõæÊòæÁ§∫ÂÆåÊàêÔºà‰øùÊåÅÂÆΩÈ´òÊØîÔºâ');
        }
      } catch (error) {
        console.error('ÊòæÁ§∫ËÉåÊôØÂõæÂ§±Ë¥•:', error);
      }
    },

    // --- „ÄêÊ†∏ÂøÉÊ∏≤ÊüìÂáΩÊï∞ - ‰∏•Ê†ºÊåâÁÖßapp.min.jsÁöÑÂõæÂ±ÇÈ°∫Â∫è„Äë ---
    async renderMockup(coverImage) {
      this.isLoading = true;
      const canvas = this.$refs.mockupCanvas;
      const ctx = canvas.getContext('2d');

      try {
        console.log('=== ÂºÄÂßãÊ∏≤ÊüìÔºå‰∏•Ê†ºÊåâÁÖßÂõæÂ±ÇÈ°∫Â∫è ===');
        console.log('Â∞ÅÈù¢ÂõæÁâá:', coverImage ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
        
        this.adjustCanvasSize(canvas);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = canvas.width / this.template.width;
        
        console.log('CanvasÂ∞∫ÂØ∏:', canvas.width, 'x', canvas.height, 'Áº©ÊîæÊØî‰æã:', scale);

        // === Á¨¨1Ê≠•ÔºöÁªòÂà∂ËÉåÊôØÂõæÂ±Ç (ÊúÄÂ∫ïÂ±Ç) ===
        console.log('Á¨¨1Ê≠•ÔºöÁªòÂà∂ËÉåÊôØÂõæÂ±Ç');
        const backgroundLayer = this.template.layers.find(l => l.id === 'background');
        if (!backgroundLayer) throw new Error("Ê®°Êùø‰∏≠Êú™ÊâæÂà∞ËÉåÊôØÂõæÂ±Ç");
        
        const backgroundImg = await this.loadImage(backgroundLayer.src);
        
        // ‰øÆÂ§çÔºö‰øùÊåÅËÉåÊôØÂõæÂéüÂßãÂÆΩÈ´òÊØîÔºåËá™ÈÄÇÂ∫îÊòæÁ§∫
        const bgAspectRatio = backgroundImg.width / backgroundImg.height;
        const canvasAspectRatio = canvas.width / canvas.height;
        
        let bgWidth, bgHeight, bgX, bgY;
        
        if (canvasAspectRatio > bgAspectRatio) {
          // CanvasÊõ¥ÂÆΩÔºå‰ª•È´òÂ∫¶‰∏∫ÂáÜ
          bgHeight = canvas.height;
          bgWidth = bgHeight * bgAspectRatio;
          bgX = (canvas.width - bgWidth) / 2;
          bgY = 0;
        } else {
          // CanvasÊõ¥È´òÔºå‰ª•ÂÆΩÂ∫¶‰∏∫ÂáÜ
          bgWidth = canvas.width;
          bgHeight = bgWidth / bgAspectRatio;
          bgX = 0;
          bgY = (canvas.height - bgHeight) / 2;
        }
        
        console.log('ËÉåÊôØÂõæËá™ÈÄÇÂ∫îÂèÇÊï∞:', { bgWidth, bgHeight, bgX, bgY });
        ctx.drawImage(backgroundImg, bgX, bgY, bgWidth, bgHeight);
        console.log('‚úì ËÉåÊôØÂõæÂ±ÇÁªòÂà∂ÂÆåÊàêÔºà‰øùÊåÅÂÆΩÈ´òÊØîÔºâ');

        // === Á¨¨2Ê≠•ÔºöÁªòÂà∂Áî®Êà∑Â∞ÅÈù¢ (ÈÄèËßÜÂèòÊç¢) ===
        if (coverImage) {
          console.log('Á¨¨2Ê≠•ÔºöÁªòÂà∂Áî®Êà∑Â∞ÅÈù¢ÔºàÈÄèËßÜÂèòÊç¢Ôºâ');
          const coverLayer = this.template.layers.find(l => l.type === 'transformed-image' && l.name === 'cover');
          if (coverLayer) {
            console.log('Â∞ÅÈù¢ÂõæÂ±ÇÂùêÊ†á:', coverLayer.destPoints);
            this.drawTransformedImage(ctx, coverImage, coverLayer.destPoints, scale);
            console.log('‚úì Â∞ÅÈù¢ÂõæÂ±ÇÁªòÂà∂ÂÆåÊàê');
          }
        } else {
          console.log('Á¨¨2Ê≠•ÔºöË∑≥ËøáÂ∞ÅÈù¢ÂõæÂ±ÇÔºàÊó†Â∞ÅÈù¢ÂõæÁâáÔºâ');
        }

        // === Á¨¨3Ê≠•ÔºöÁªòÂà∂ÂÖâÂΩ±ÊïàÊûúÂõæÂ±Ç ===
        console.log('Á¨¨3Ê≠•ÔºöÁªòÂà∂ÂÖâÂΩ±ÊïàÊûúÂõæÂ±Ç');
        const highlightsLayer = this.template.layers.find(l => l.id === 'highlights');
        if (highlightsLayer) {
          const highlightsImg = await this.loadImage(highlightsLayer.src);
          
          // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂÖâÂΩ±ÊïàÊûúÂ∫îËØ•Âè™Ë¶ÜÁõñÂ∞ÅÈù¢Âå∫ÂüüÔºåÂ¢ûÂä†‰π¶Êú¨Á∫πÁêÜ
          // ‰ΩøÁî®‰∏éÂ∞ÅÈù¢Áõ∏ÂêåÁöÑÂùêÊ†áÂå∫ÂüüÊù•ÁªòÂà∂ÂÖâÂΩ±ÊïàÊûú
          const coverLayer = this.template.layers.find(l => l.type === 'transformed-image' && l.name === 'cover');
          if (coverLayer) {
            console.log('‰ΩøÁî®Â∞ÅÈù¢ÂùêÊ†áÂå∫ÂüüÁªòÂà∂ÂÖâÂΩ±ÊïàÊûú');
            
            // ËÆ°ÁÆóÂÖâÂΩ±ÊïàÊûúÁöÑÁªòÂà∂Âå∫ÂüüÔºà‰∏éÂ∞ÅÈù¢Âå∫ÂüüÂÆåÂÖ®‰∏ÄËá¥Ôºâ
            const dest = coverLayer.destPoints.map(p => ({ x: p.x * scale, y: p.y * scale }));
            
            // ËÆ°ÁÆóËæπÁïåÊ°ÜÔºà‰∏éÂ∞ÅÈù¢ÂÆåÂÖ®‰∏ÄËá¥Ôºâ
            const minX = Math.min(...dest.map(p => p.x));
            const minY = Math.min(...dest.map(p => p.y));
            const maxX = Math.max(...dest.map(p => p.x));
            const maxY = Math.max(...dest.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            
            console.log('ÂÖâÂΩ±ÊïàÊûúÁªòÂà∂Âå∫Âüü:', { minX, minY, width, height });
            
            // Âè™Âú®Ëøô‰∏™Âå∫ÂüüÂÜÖÁªòÂà∂ÂÖâÂΩ±ÊïàÊûú
            ctx.save();
            ctx.beginPath();
            ctx.rect(minX, minY, width, height);
            ctx.clip();
            
            // ÁªòÂà∂ÂÖâÂΩ±ÊïàÊûúÔºå‰ΩÜÂè™Âú®Ëøô‰∏™Âå∫ÂüüÂÜÖ
            ctx.drawImage(highlightsImg, minX, minY, width, height);
            ctx.restore();
            
            console.log('‚úì ÂÖâÂΩ±ÊïàÊûúÂõæÂ±ÇÁªòÂà∂ÂÆåÊàêÔºàÈôêÂà∂Âú®Â∞ÅÈù¢Âå∫ÂüüÔºâ');
          } else {
            // Â¶ÇÊûúÊ≤°ÊúâÂ∞ÅÈù¢ÂõæÂ±ÇÔºåÂàôÊåâÂéüÊù•ÁöÑÊñπÂºèÁªòÂà∂
            ctx.drawImage(highlightsImg, 0, 0, canvas.width, canvas.height);
            console.log('‚úì ÂÖâÂΩ±ÊïàÊûúÂõæÂ±ÇÁªòÂà∂ÂÆåÊàêÔºàÂÖ®CanvasË¶ÜÁõñÔºâ');
          }
        }

        // === Á¨¨4Ê≠•ÔºöÁªòÂà∂ÂâçÊôØËíôÁâàÂõæÂ±Ç (ÊâãÊåá) ===
        console.log('Á¨¨4Ê≠•ÔºöÁªòÂà∂ÂâçÊôØËíôÁâàÂõæÂ±ÇÔºàÊâãÊåáÔºâ- Â∑≤Ê≥®ÈáäÊéâ');
        // ÊöÇÊó∂Ê≥®ÈáäÊéâÊâãÊåáËíôÁâàÊ∏≤ÊüìÔºåÂÖàÁúãÂ∞ÅÈù¢ÊïàÊûú
        /*
        const maskLayer = this.template.layers.find(l => l.id === 'mask');
        if (maskLayer) {
          const maskImg = await this.loadImage(maskLayer.src);
          
          // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊâãÊåáËíôÁâàÂ∫îËØ•Âè™Ë¶ÜÁõñ‰π¶Êú¨Âå∫ÂüüÔºå‰∏çÊòØÊï¥‰∏™Canvas
          // ‰ΩøÁî®‰∏éÂ∞ÅÈù¢Áõ∏ÂêåÁöÑÂùêÊ†áÂå∫ÂüüÊù•ÁªòÂà∂ÊâãÊåáËíôÁâà
          const coverLayer = this.template.layers.find(l => l.type === 'transformed-image' && l.name === 'cover');
          if (coverLayer) {
            console.log('‰ΩøÁî®Â∞ÅÈù¢ÂùêÊ†áÂå∫ÂüüÁªòÂà∂ÊâãÊåáËíôÁâà');
            
            // ËÆ°ÁÆóÊâãÊåáËíôÁâàÁöÑÁªòÂà∂Âå∫ÂüüÔºà‰∏éÂ∞ÅÈù¢Âå∫ÂüüÂÆåÂÖ®‰∏ÄËá¥Ôºâ
            const dest = coverLayer.destPoints.map(p => ({ x: p.x * scale, y: p.y * scale }));
            
            // ËÆ°ÁÆóËæπÁïåÊ°ÜÔºà‰∏éÂ∞ÅÈù¢ÂÆåÂÖ®‰∏ÄËá¥Ôºâ
            const minX = Math.min(...dest.map(p => p.x));
            const minY = Math.min(...dest.map(p => p.y));
            const maxX = Math.max(...dest.map(p => p.x));
            const maxY = Math.max(...dest.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            
            console.log('ÊâãÊåáËíôÁâàÁªòÂà∂Âå∫Âüü:', { minX, minY, width, height });
            
            // Âè™Âú®Ëøô‰∏™Âå∫ÂüüÂÜÖÁªòÂà∂ÊâãÊåáËíôÁâà
            ctx.save();
            ctx.beginPath();
            ctx.rect(minX, minY, width, height);
            ctx.clip();
            
            // ÁªòÂà∂ÊâãÊåáËíôÁâàÔºå‰ΩÜÂè™Âú®Ëøô‰∏™Âå∫ÂüüÂÜÖ
            ctx.drawImage(maskImg, minX, minY, width, height);
            ctx.restore();
            
            console.log('‚úì ÊâãÊåáËíôÁâàÂõæÂ±ÇÁªòÂà∂ÂÆåÊàêÔºàÈôêÂà∂Âú®Â∞ÅÈù¢Âå∫ÂüüÔºâ');
          } else {
            // Â¶ÇÊûúÊ≤°ÊúâÂ∞ÅÈù¢ÂõæÂ±ÇÔºåÂàôÊåâÂéüÊù•ÁöÑÊñπÂºèÁªòÂà∂
            ctx.drawImage(maskImg, 0, 0, canvas.width, canvas.height);
            console.log('‚úì ÊâãÊåáËíôÁâàÂõæÂ±ÇÁªòÂà∂ÂÆåÊàêÔºàÂÖ®CanvasË¶ÜÁõñÔºâ');
          }
        }
        */
        console.log('‚úì ÊâãÊåáËíôÁâàÂõæÂ±ÇÂ∑≤Ë∑≥ËøáÔºàÊ≥®ÈáäÊéâÔºâ');
        
        console.log('=== Ê∏≤ÊüìÂÆåÊàêÔºåÂõæÂ±ÇÈ°∫Â∫èÔºöËÉåÊôØ‚ÜíÂ∞ÅÈù¢‚ÜíÂÖâÂΩ±‚ÜíÊâãÊåá ===');
      } catch (error) {
        console.error("Ê∏≤ÊüìËøáÁ®ã‰∏≠Âá∫Èîô:", error);
        this.$message.error("Ê∏≤ÊüìÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞„ÄÇ");
      } finally {
        this.isLoading = false;
      }
    },

    drawTransformedImage(ctx, image, destPoints, scale) {
      console.log('=== ÈÄèËßÜÂèòÊç¢ÂºÄÂßã ===');
      console.log('ÂõæÁâáÂ∞∫ÂØ∏:', image.width, 'x', image.height);
      console.log('ÂéüÂßãÂùêÊ†áÁÇπ:', destPoints);
      console.log('Áº©ÊîæÊØî‰æã:', scale);
      
      // ‰øÆÂ§çVue ObserverÈóÆÈ¢òÔºåÊ≠£Á°ÆËé∑ÂèñÂùêÊ†áÂÄº
      const dest = destPoints.map(p => {
        // Á°Æ‰øùËÉΩÊ≠£Á°ÆËÆøÈóÆx, yÂ±ûÊÄß
        const x = p.x || (p._value && p._value.x) || 0;
        const y = p.y || (p._value && p._value.y) || 0;
        return { x: x * scale, y: y * scale };
      });
      console.log('Áº©ÊîæÂêéÁöÑÁõÆÊ†áÂùêÊ†á:', dest);
      
      // ÁâπÂà´Ê†áÊ≥®Â∑¶‰∏ãËßíÂùêÊ†á
      console.log('üî¥ destPointsÊï∞ÁªÑÈïøÂ∫¶:', destPoints.length);
      console.log('üî¥ destPointsÂÆåÊï¥Êï∞ÁªÑ:', destPoints);
      
      // Ê£ÄÊü•Êï∞ÁªÑÁªìÊûÑÔºå‰øÆÂ§çObserverËÆøÈóÆÈóÆÈ¢ò
      destPoints.forEach((point, index) => {
        const x = point.x || (point._value && point._value.x) || 0;
        const y = point.y || (point._value && point._value.y) || 0;
        console.log(`üî¥ ÁÇπ${index}: x=${x}, y=${y}`);
      });
      
      const bottomLeft = dest[3]; // Á¨¨Âõõ‰∏™ÁÇπÊòØÂ∑¶‰∏ãËßí
      console.log('üî¥ Â∑¶‰∏ãËßíÂùêÊ†á:', bottomLeft);
      
      // Ëé∑ÂèñÂ∑¶‰∏ãËßíÂéüÂßãÂÄº
      const bottomLeftOriginal = destPoints[3];
      const bottomLeftX = bottomLeftOriginal.x || (bottomLeftOriginal._value && bottomLeftOriginal._value.x) || 0;
      const bottomLeftY = bottomLeftOriginal.y || (bottomLeftOriginal._value && bottomLeftOriginal._value.y) || 0;
      console.log('üî¥ Â∑¶‰∏ãËßíÂéüÂßãÂÄº: x=', bottomLeftX, 'y=', bottomLeftY);
      
      // „ÄêÈáçË¶Å‰øÆÂ§ç„Äë‰ΩøÁî®ÁúüÊ≠£ÁöÑÂõõËæπÂΩ¢Ê∏≤ÊüìÔºåÊåâÁÖßÂõõ‰∏™ÂùêÊ†áÁÇπÂõ¥ÊàêÁöÑÂΩ¢Áä∂
      console.log('‚úÖ ‰ΩøÁî®ÁúüÊ≠£ÁöÑÂõõËæπÂΩ¢Ê∏≤ÊüìÔºåÊåâÁÖßÂõõ‰∏™ÂùêÊ†áÁÇπÂõ¥ÊàêÁöÑÂΩ¢Áä∂');
      
      // ‰ΩøÁî®CanvasÁöÑË∑ØÂæÑÁªòÂà∂ÂõõËæπÂΩ¢
      ctx.save();
      ctx.globalAlpha = 0.9; // Â¢ûÂä†ÈÄèÊòéÂ∫¶
      
      // ÂàõÂª∫ÂõõËæπÂΩ¢Ë∑ØÂæÑÔºåÁ°Æ‰øùÂùêÊ†áÊ≠£Á°Æ
      console.log('ÂºÄÂßãÁªòÂà∂ÂõõËæπÂΩ¢Ë∑ØÂæÑ...');
      console.log('Ë∑ØÂæÑÂùêÊ†á:', dest);
      
      // ÊåâÁÖßÊ≠£Á°ÆÁöÑÈ°∫Â∫èÁªòÂà∂ÂõõËæπÂΩ¢ÔºöÂ∑¶‰∏ä‚ÜíÂè≥‰∏ä‚ÜíÂè≥‰∏ã‚ÜíÂ∑¶‰∏ã‚ÜíÂ∑¶‰∏ä
      ctx.beginPath();
      
      // Â∑¶‰∏äËßí
      ctx.moveTo(dest[0].x, dest[0].y);
      console.log('ÁßªÂä®Âà∞Â∑¶‰∏ä:', dest[0].x, dest[0].y);
      
      // Âè≥‰∏äËßí
      ctx.lineTo(dest[1].x, dest[1].y);
      console.log('ËøûÁ∫øÂà∞Âè≥‰∏ä:', dest[1].x, dest[1].y);
      
      // Âè≥‰∏ãËßí
      ctx.lineTo(dest[2].x, dest[2].y);
      console.log('ËøûÁ∫øÂà∞Âè≥‰∏ã:', dest[2].x, dest[2].y);
      
      // Â∑¶‰∏ãËßí
      ctx.lineTo(dest[3].x, dest[3].y);
      console.log('ËøûÁ∫øÂà∞Â∑¶‰∏ã:', dest[3].x, dest[3].y);
      
      // ÂõûÂà∞Â∑¶‰∏äËßíÔºåÂΩ¢ÊàêÈó≠ÂêàË∑ØÂæÑ
      ctx.lineTo(dest[0].x, dest[0].y);
      console.log('ÂõûÂà∞Â∑¶‰∏ä:', dest[0].x, dest[0].y);
      
      ctx.closePath();
      console.log('ÂõõËæπÂΩ¢Ë∑ØÂæÑÁªòÂà∂ÂÆåÊàê');
      
      // Ë∞ÉËØïÔºöË∑ØÂæÑËΩÆÂªìÂ∑≤Ê≥®ÈáäÊéâÔºàÂéªÊéâÁ∫¢Ëâ≤ÂúàÔºâ
      // ctx.strokeStyle = 'red';
      // ctx.lineWidth = 2;
      // ctx.stroke();
      console.log('Ë∑ØÂæÑËΩÆÂªìÁªòÂà∂Â∑≤Ë∑≥ËøáÔºàÂéªÊéâÁ∫¢Ëâ≤ÂúàÔºâ');
      
      // ËÆæÁΩÆË£ÅÂâ™Âå∫Âüü‰∏∫ÂõõËæπÂΩ¢
      ctx.clip();
      console.log('Ë£ÅÂâ™Âå∫ÂüüËÆæÁΩÆÂÆåÊàê');
      
      // ËÆ°ÁÆóÂõæÁâáÁöÑÁªòÂà∂Âå∫ÂüüÔºà‰ΩøÁî®Âõõ‰∏™ÂùêÊ†áÁÇπÁöÑËæπÁïåÔºâ
      const minX = Math.min(...dest.map(p => p.x));
      const minY = Math.min(...dest.map(p => p.y));
      const maxX = Math.max(...dest.map(p => p.x));
      const maxY = Math.max(...dest.map(p => p.y));
      const width = maxX - minX;
      const height = maxY - minY;
      
      console.log('ÂõõËæπÂΩ¢ËæπÁïåÊ°Ü:', { minX, minY, width, height });
      console.log('Âõõ‰∏™ÂùêÊ†áÁÇπ:', dest);
      
      // Âú®ÂõõËæπÂΩ¢Âå∫ÂüüÂÜÖÁªòÂà∂ÂõæÁâá
      ctx.drawImage(image, minX, minY, width, height);
      console.log('ÂõæÁâáÁªòÂà∂ÂÆåÊàê');
      
      ctx.restore();
      
      console.log('‚úÖ ÈÄèËßÜÂèòÊç¢ÂÆåÊàêÔºàÂõõËæπÂΩ¢Âå∫ÂüüÊ∏≤ÊüìÔºâ');
      console.log('=== ÈÄèËßÜÂèòÊç¢ÁªìÊùü ===');
    },

    drawTriangle(ctx, image, src, dst) {
      console.log('ÁªòÂà∂‰∏âËßíÂΩ¢:', { src, dst });
      
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(dst[0].x, dst[0].y);
      ctx.lineTo(dst[1].x, dst[1].y);
      ctx.lineTo(dst[2].x, dst[2].y);
      ctx.closePath();
      ctx.clip();
      
      // ËÆ°ÁÆóÂèòÊç¢Áü©Èòµ
      const t = this.getTransform(src, dst);
      console.log('ÂèòÊç¢Áü©Èòµ:', t);
      
      // Â∫îÁî®ÂèòÊç¢
      ctx.transform(t.a, t.b, t.c, t.d, t.e, t.f);
      
      // ÁªòÂà∂ÂõæÁâá
      ctx.drawImage(image, 0, 0);
      
      // ÊÅ¢Â§çCanvasÁä∂ÊÄÅ
      ctx.restore();
      
      console.log('‰∏âËßíÂΩ¢ÁªòÂà∂ÂÆåÊàê');
    },

    getTransform(src, dst) {
      const D = src[0].x * (src[1].y - src[2].y) + src[1].x * (src[2].y - src[0].y) + src[2].x * (src[0].y - src[1].y);
      if (D === 0) return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
      return {
        a: (dst[0].x * (src[1].y - src[2].y) + dst[1].x * (src[2].y - src[0].y) + dst[2].x * (src[0].y - src[1].y)) / D,
        b: (dst[0].y * (src[1].y - src[2].y) + dst[1].y * (src[2].y - src[0].y) + dst[2].y * (src[0].y - src[1].y)) / D,
        c: (dst[0].x * (src[2].x - src[1].x) + dst[1].x * (src[0].x - src[2].x) + dst[2].x * (src[1].x - src[0].x)) / D,
        d: (dst[0].y * (src[2].x - src[1].x) + dst[1].y * (src[0].x - src[2].x) + dst[2].y * (src[1].x - src[0].x)) / D,
        e: (dst[0].x * (src[1].y * src[2].x - src[2].y * src[1].x) + dst[1].x * (src[2].y * src[0].x - src[0].y * src[2].x) + dst[2].x * (src[0].y * src[1].x - src[1].y * src[0].x)) / D,
        f: (dst[0].y * (src[1].y * src[2].x - src[2].y * src[1].x) + dst[1].y * (src[2].y * src[0].x - src[0].y * src[2].x) + dst[2].y * (src[0].y * src[1].x - src[1].y * src[0].x)) / D,
      };
    },



    // ÁúüÊ≠£ÁöÑ‰ºòÂåñÁâàÊâãÈÉ®ÈÅÆÁΩ©ÂêàÊàêÁÆóÊ≥ï - ÊâãÊåáÈÄèÊòé + ËæπÁºòÊöóÂåñ
    async mergeUserImageWithHandMask(userImage) {
      console.log('ÂºÄÂßãÁúüÊ≠£ÁöÑ‰ºòÂåñÁâàÊâãÈÉ®ÈÅÆÁΩ©ÂêàÊàêÔºàÊâãÊåáÈÄèÊòé + ËæπÁºòÊöóÂåñÔºâ...');
      
      if (!userImage) {
        console.error('Áî®Êà∑ÂõæÁâá‰∏çÂ≠òÂú®');
        return null;
      }

      try {
        // Âä†ËΩΩÊâãÈÉ®ÈÅÆÁΩ©
        const handMask = await this.loadImage(bookMask1);
        
        // ÂàõÂª∫‰∏¥Êó∂CanvasËøõË°åÂêàÊàê
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // ËÆæÁΩÆCanvasÂ∞∫ÂØ∏‰∏∫Áî®Êà∑ÂõæÁâáÂ∞∫ÂØ∏
        tempCanvas.width = userImage.width;
        tempCanvas.height = userImage.height;
        
        console.log(`ÂêàÊàêÂ∞∫ÂØ∏: ${tempCanvas.width}x${tempCanvas.height}`);
        
        // 1. ÁªòÂà∂Áî®Êà∑ÂõæÁâá‰Ωú‰∏∫Â∫ïÂõæ
        tempCtx.drawImage(userImage, 0, 0, tempCanvas.width, tempCanvas.height);
        
        // 2. ÂàõÂª∫ÊâãÈÉ®ÈÅÆÁΩ©CanvasÂπ∂ËøõË°åËæπÁºòÂπ≥ÊªëÂ§ÑÁêÜ
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        maskCanvas.width = tempCanvas.width;
        maskCanvas.height = tempCanvas.height;
        
        // ÁªòÂà∂Ë∞ÉÊï¥Â∞∫ÂØ∏ÂêéÁöÑÊâãÈÉ®ÈÅÆÁΩ©
        maskCtx.drawImage(handMask, 0, 0, maskCanvas.width, maskCanvas.height);
        
        // 3. Â§öÁ∫ßËæπÁºòÂπ≥ÊªëÂ§ÑÁêÜÔºàÊ®°ÊãüPythonÁöÑÂÆåÊï¥ÁÆóÊ≥ïÔºâ
        console.log('ÂºÄÂßãÂ§öÁ∫ßËæπÁºòÂπ≥ÊªëÂ§ÑÁêÜ...');
        
        // Á¨¨‰∏ÄÁ∫ßÔºöËΩªÂæÆÈ´òÊñØÊ®°Á≥äÔºåËΩØÂåñËæπÁºò
        maskCtx.filter = 'blur(1.5px)'; // Â¢ûÂä†Ê®°Á≥äÂçäÂæÑÔºåÊõ¥Ëá™ÁÑ∂
        maskCtx.drawImage(maskCanvas, 0, 0);
        maskCtx.filter = 'none';
        
        // Á¨¨‰∫åÁ∫ßÔºöÂ∫îÁî®ÂØπÊØîÂ∫¶Ë∞ÉÊï¥ÔºåËÆ©ËæπÁºòÊõ¥ÊüîÂíå
        maskCtx.filter = 'contrast(0.9)'; // Èôç‰ΩéÂØπÊØîÂ∫¶ÔºåÂáèÂ∞ëÁ°¨ËæπÁºò
        maskCtx.drawImage(maskCanvas, 0, 0);
        maskCtx.filter = 'none';
        
        // Á¨¨‰∏âÁ∫ßÔºöÂ∫îÁî®‰∫ÆÂ∫¶Ë∞ÉÊï¥ÔºåËÆ©ÊâãÈÉ®Âå∫ÂüüÊõ¥Ëá™ÁÑ∂
        maskCtx.filter = 'brightness(1.1)'; // ËΩªÂæÆÊèê‰∫ÆÔºåÂáèÂ∞ëPSÁóïËøπ
        maskCtx.drawImage(maskCanvas, 0, 0);
        maskCtx.filter = 'none';
        
        // 4. Ëé∑ÂèñÂÉèÁ¥†Êï∞ÊçÆËøõË°åÂêàÊàê
        const userImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
        const resultImageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
        
        const userPixels = userImageData.data;
        const maskPixels = maskImageData.data;
        const resultPixels = resultImageData.data;
        
        console.log('ÂºÄÂßãÂÉèÁ¥†Á∫ßÂêàÊàêÂ§ÑÁêÜÔºàÊâãÊåáÈÄèÊòé + ËæπÁºòÊöóÂåñÔºâ...');
        
        // 5. ÁúüÊ≠£ÁöÑ‰ºòÂåñÁâàÂêàÊàêÁÆóÊ≥ïÔºàÊâãÊåáÈÄèÊòé + ËæπÁºòÊöóÂåñÔºâ
        const whiteThreshold = 240; // ÁôΩËâ≤ÈòàÂÄº
        const transparencyFactor = 0.6; // ÊâãÊåáÈÄèÊòéÂ∫¶Âõ†Â≠êÔºà0.6 = 40%ÈÄèÊòéÔºâ
        const edgeDarkenFactor = 0.5; // ËæπÁºòÊöóÂåñÂõ†Â≠êÔºà0.5 = ÊöóÂåñ50%Ôºâ
        let handRegionCount = 0;
        let transparentPixelsCount = 0;
        let edgeDarkenedCount = 0;
        
        // ÂçïÈÅçÊâ´ÊèèÔºåÁõ¥Êé•Â§ÑÁêÜÊØè‰∏™ÂÉèÁ¥†
        for (let i = 0; i < userPixels.length; i += 4) {
          const maskR = maskPixels[i];
          const maskG = maskPixels[i + 1];
          const maskB = maskPixels[i + 2];
          const maskA = maskPixels[i + 3];
          
          // Ê£ÄÊµãÊòØÂê¶‰∏∫ÊâãÈÉ®Âå∫Âüü
          const isWhite = maskR > whiteThreshold && maskG > whiteThreshold && maskB > whiteThreshold;
          
          if (isWhite) {
            // ÁôΩËâ≤Âå∫ÂüüÔºö‰øùÊåÅÁî®Êà∑ÂõæÁâá
            resultPixels[i] = userPixels[i];
            resultPixels[i + 1] = userPixels[i + 1];
            resultPixels[i + 2] = userPixels[i + 2];
            resultPixels[i + 3] = userPixels[i + 3];
          } else {
            // ÈùûÁôΩËâ≤Âå∫ÂüüÔºöÊâãÈÉ®ÈÅÆÁΩ©Â§ÑÁêÜ
            
            // ËÆ°ÁÆóÊâãÈÉ®ÂÉèÁ¥†ÁöÑ‰∫ÆÂ∫¶ÔºàÁî®‰∫éÂà§Êñ≠ËæπÁºòÔºâ
            const brightness = (maskR + maskG + maskB) / 3;
            
            // Âà§Êñ≠ÊòØÂê¶‰∏∫ËæπÁºòÂÉèÁ¥†Ôºà‰∫ÆÂ∫¶Êé•ËøëÁôΩËâ≤ÈòàÂÄºÔºâ
            const isEdgePixel = brightness > (whiteThreshold - 30); // ËæπÁºòÊ£ÄÊµãÈòàÂÄº
            
            if (isEdgePixel) {
              // ËæπÁºòÂÉèÁ¥†ÔºöÂ∫îÁî®ËæπÁºòÊöóÂåñ + ÈÄèÊòéÂ∫¶
              const edgeDarkness = (brightness - (whiteThreshold - 30)) / 30; // 0-1ÁöÑÊöóÂåñÁ®ãÂ∫¶
              const finalDarkness = edgeDarkness * (1 - edgeDarkenFactor);
              
              // ËæπÁºòÊöóÂåñÂ§ÑÁêÜ
              resultPixels[i] = Math.round(maskR * (1 - finalDarkness));     // R
              resultPixels[i + 1] = Math.round(maskG * (1 - finalDarkness)); // G
              resultPixels[i + 2] = Math.round(maskB * (1 - finalDarkness)); // B
              resultPixels[i + 3] = Math.round(maskA * transparencyFactor);  // A Èôç‰ΩéÈÄèÊòéÂ∫¶
              
              edgeDarkenedCount++;
            } else {
              // Ê†∏ÂøÉÊâãÈÉ®ÂÉèÁ¥†Ôºö‰øùÊåÅÂéüËâ≤Ôºå‰ΩÜÈôç‰ΩéÈÄèÊòéÂ∫¶
              resultPixels[i] = maskR;
              resultPixels[i + 1] = maskG;
              resultPixels[i + 2] = maskB;
              resultPixels[i + 3] = Math.round(maskA * transparencyFactor); // A Èôç‰ΩéÈÄèÊòéÂ∫¶
            }
            
            handRegionCount++;
            transparentPixelsCount++;
          }
        }
        
        console.log(`ÊâãÈÉ®Âå∫ÂüüÂÉèÁ¥†Êï∞: ${handRegionCount}`);
        console.log(`ÈÄèÊòéÂåñÂÉèÁ¥†Êï∞: ${transparentPixelsCount}`);
        console.log(`ËæπÁºòÊöóÂåñÂÉèÁ¥†Êï∞: ${edgeDarkenedCount}`);
        console.log(`ÊâãÊåáÈÄèÊòéÂ∫¶: ${(1 - transparencyFactor) * 100}%`);
        console.log(`ËæπÁºòÊöóÂåñÂº∫Â∫¶: ${(1 - edgeDarkenFactor) * 100}%`);
        
        // 6. Â∞ÜÂêàÊàêÁªìÊûúÁªòÂà∂Âà∞‰∏¥Êó∂Canvas
        tempCtx.putImageData(resultImageData, 0, 0);
        
        // 7. ÊúÄÁªàËæπÁºòÂπ≥ÊªëÂ§ÑÁêÜ
        console.log('Â∫îÁî®ÊúÄÁªàËæπÁºòÂπ≥Êªë...');
        tempCtx.filter = 'blur(0.5px)'; // ËΩªÂæÆÊ®°Á≥äÔºåËøõ‰∏ÄÊ≠•Âπ≥ÊªëËæπÁºò
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        
        const mergedImageDataUrl = tempCanvas.toDataURL('image/png');
        const mergedImage = await this.loadImage(mergedImageDataUrl);
        
        console.log('‚úì ÁúüÊ≠£ÁöÑ‰ºòÂåñÁâàÊâãÈÉ®ÈÅÆÁΩ©ÂêàÊàêÂÆåÊàêÔºàÊâãÊåáÈÄèÊòé + ËæπÁºòÊöóÂåñÔºâ');
        return mergedImage;
        
      } catch (error) {
        console.error('ÂêàÊàêËøáÁ®ã‰∏≠Âá∫Èîô:', error);
        return null;
      }
    },

    // ‰ΩøÁî®ÂêàÊàêÂêéÁöÑÂõæÁâáËøõË°å‰π¶Êú¨Ê∏≤Êüì
    async renderMockupWithMergedImage(mergedImage) {
      console.log('ÂºÄÂßã‰ΩøÁî®ÂêàÊàêÂõæÁâáËøõË°å‰π¶Êú¨Ê∏≤Êüì...');
      
      const canvas = this.$refs.mockupCanvas;
      const ctx = canvas.getContext('2d');

      try {
        this.adjustCanvasSize(canvas);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const scale = canvas.width / this.template.width;

        // === Á¨¨1Ê≠•ÔºöÁªòÂà∂ËÉåÊôØÂõæÂ±Ç ===
        const backgroundLayer = this.template.layers.find(l => l.id === 'background');
        if (backgroundLayer) {
          const backgroundImg = await this.loadImage(backgroundLayer.src);
          
          // ‰øùÊåÅËÉåÊôØÂõæÂéüÂßãÂÆΩÈ´òÊØîÔºåËá™ÈÄÇÂ∫îÊòæÁ§∫
          const bgAspectRatio = backgroundImg.width / backgroundImg.height;
          const canvasAspectRatio = canvas.width / canvas.height;
          
          let bgWidth, bgHeight, bgX, bgY;
          
          if (canvasAspectRatio > bgAspectRatio) {
            bgHeight = canvas.height;
            bgWidth = bgHeight * bgAspectRatio;
            bgX = (canvas.width - bgWidth) / 2;
            bgY = 0;
          } else {
            bgWidth = canvas.width;
            bgHeight = bgWidth / bgAspectRatio;
            bgX = 0;
            bgY = (canvas.height - bgHeight) / 2;
          }
          
          ctx.drawImage(backgroundImg, bgX, bgY, bgWidth, bgHeight);
          console.log('‚úì ËÉåÊôØÂõæÂ±ÇÁªòÂà∂ÂÆåÊàê');
        }

        // === Á¨¨2Ê≠•ÔºöÁªòÂà∂ÂêàÊàêÂêéÁöÑÁî®Êà∑Â∞ÅÈù¢ÔºàÈÄèËßÜÂèòÊç¢Ôºâ===
        const coverLayer = this.template.layers.find(l => l.type === 'transformed-image' && l.name === 'cover');
        if (coverLayer) {
          this.drawTransformedImage(ctx, mergedImage, coverLayer.destPoints, scale);
          console.log('‚úì ÂêàÊàêÂ∞ÅÈù¢ÂõæÂ±ÇÁªòÂà∂ÂÆåÊàê');
        }

        // === Á¨¨3Ê≠•ÔºöÁªòÂà∂ÂÖâÂΩ±ÊïàÊûúÂõæÂ±Ç ===
        const highlightsLayer = this.template.layers.find(l => l.id === 'highlights');
        if (highlightsLayer) {
          const highlightsImg = await this.loadImage(highlightsLayer.src);
          
          // ÈôêÂà∂ÂÖâÂΩ±ÊïàÊûúÂú®Â∞ÅÈù¢Âå∫Âüü
          if (coverLayer) {
            const dest = coverLayer.destPoints.map(p => ({ x: p.x * scale, y: p.y * scale }));
            const minX = Math.min(...dest.map(p => p.x));
            const minY = Math.min(...dest.map(p => p.y));
            const maxX = Math.max(...dest.map(p => p.x));
            const maxY = Math.max(...dest.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(minX, minY, width, height);
            ctx.clip();
            ctx.drawImage(highlightsImg, minX, minY, width, height);
            ctx.restore();
          } else {
            ctx.drawImage(highlightsImg, 0, 0, canvas.width, canvas.height);
          }
          console.log('‚úì ÂÖâÂΩ±ÊïàÊûúÂõæÂ±ÇÁªòÂà∂ÂÆåÊàê');
        }

        console.log('‚úì ‰π¶Êú¨Ê∏≤ÊüìÂÆåÊàê');
        
      } catch (error) {
        console.error('‰π¶Êú¨Ê∏≤ÊüìËøáÁ®ã‰∏≠Âá∫Èîô:', error);
        throw error;
      }
    },
  },
};
</script>

<style scoped>
.page-container {
  min-height: 100vh;
  background-color: #ffffff;
  width: 100vw !important; /* Âº∫Âà∂‰ΩøÁî®ËßÜÂè£ÂÆΩÂ∫¶ */
  max-width: none !important; /* ÁßªÈô§‰ªª‰ΩïÊúÄÂ§ßÂÆΩÂ∫¶ÈôêÂà∂ */
  margin: 0 !important;
  padding: 0 !important;
  position: relative;
  left: 0;
  right: 0;
  box-sizing: border-box;
}

/* Header Âõ∫ÂÆöÁΩÆÈ°∂ÔºåË¶ÜÁõñÂÖ®Â±è */
.page-container :deep(.header) {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  width: 100vw !important; /* Âº∫Âà∂‰ΩøÁî®ËßÜÂè£ÂÆΩÂ∫¶ */
  max-width: none !important; /* ÁßªÈô§‰ªª‰ΩïÊúÄÂ§ßÂÆΩÂ∫¶ÈôêÂà∂ */
  z-index: 1000 !important;
  background-color: #ffffff !important;
  border: none !important;
  box-shadow: none !important;
  border-radius: 0 !important;
  box-sizing: border-box;
}

/* ÂÆåÂÖ®ÁßªÈô§ÂÆπÂô®Ê¶ÇÂøµÔºåÁõ¥Êé•Âú®ÂÖ®Â±èËÉåÊôØ‰∏äÂ∏ÉÂ±Ä */
.mockup-tool-container {
  width: 100%;
  margin: 0;
  padding: 0;
  padding-top: 0; /* ÁßªÈô§È°∂ÈÉ®Èó¥Ë∑ùÔºåÈÅøÂÖçÂ§ö‰ΩôÁöÑÁôΩËâ≤Âå∫Âüü */
}

/* ÁßªÈô§ÊâÄÊúâÂÆπÂô®Ê†∑ÂºèÔºåÁõ¥Êé•Âú®ÂÖ®Â±èËÉåÊôØ‰∏äÂ∏ÉÂ±Ä */
.unified-content-container {
  width: 100%;
  margin: 0;
  padding: 0;
  background-color: transparent;
  border: none;
  box-shadow: none;
  border-radius: 0;
}

/* Ê†áÈ¢òÂå∫ÂüüÁõ¥Êé•Âú®ÂÖ®Â±èËÉåÊôØ‰∏ä */
.header-section {
  width: 100%;
  padding: 0 6rem; /* Â¢ûÂä†Â∑¶Âè≥ËæπË∑ùÔºåËÆ©ÂÜÖÂÆπÊõ¥Â±Ö‰∏≠ */
  margin: 0;
  background-color: transparent;
  border: 1px solid #e5e7eb; /* Ê∑ªÂä†Èì∂Ëâ≤1pxËæπÊ°Ü */
  box-shadow: none;
  border-radius: 0;
  display: flex;
  justify-content: flex-start; /* Ê†áÈ¢òÂå∫ÂüüÂ∑¶ÂØπÈΩê */
}

/* Ê†áÈ¢òÂÜÖÂÆπÂ∑¶ÂØπÈΩê */
.header-section :deep(.page-header) {
  width: 100%;
  max-width: 1200px; /* ÈôêÂà∂ÂÜÖÂÆπÊúÄÂ§ßÂÆΩÂ∫¶ÔºåÈÅøÂÖçÂú®Â§ßÂ±èÂπï‰∏äËøáÂÆΩ */
  text-align: left; /* Ê†áÈ¢òÂÜÖÂÆπÂ∑¶ÂØπÈΩê */
  border: 1px solid transparent; /* ËæπÊ°ÜÈÄèÊòéÔºå‰∏çË¶ÅÊúâÈ¢úËâ≤ */
}

.header-section :deep(.page-header-content) {
  text-align: left; /* Á°Æ‰øùPageHeaderÂÜÖÂÆπÂ∑¶ÂØπÈΩê */
}

/* ÂäüËÉΩÂå∫ÂüüÁõ¥Êé•Âú®ÂÖ®Â±èËÉåÊôØ‰∏ä */
.function-section {
  display: flex;
  width: 100%;
  margin: 0;
  padding: 0 6rem 2rem 6rem; /* Â¢ûÂä†Â∑¶Âè≥ËæπË∑ùÔºå‰∏éÊ†áÈ¢òÂå∫Âüü‰øùÊåÅ‰∏ÄËá¥ */
  padding-top: 30px;
  background-color: transparent;
  border: none;
  box-shadow: none;
  border-radius: 0;
  justify-content: center; /* ÂäüËÉΩÂå∫ÂüüÂ±Ö‰∏≠ÂØπÈΩê */
  gap: 2rem; /* ÂáèÂ∞ëÂ∑¶Âè≥Èù¢Êùø‰πãÈó¥ÁöÑÈó¥Ë∑ùÔºåËÆ©ÊéßÂà∂Èù¢ÊùøÊõ¥Èù†ËøëÂõæÁâáÊ®°Êùø */
}

/* ÂäüËÉΩÂå∫ÂüüÂÜÖÂÆπÂÆπÂô® */
.function-section > * {
  max-width: 1200px; /* ÈôêÂà∂ÂÜÖÂÆπÊúÄÂ§ßÂÆΩÂ∫¶Ôºå‰∏éÊ†áÈ¢òÂå∫Âüü‰øùÊåÅ‰∏ÄËá¥ */
  width: 100%;
}

/* Â∑¶Âè≥Èù¢ÊùøÁõ¥Êé•Âú®ÂÖ®Â±èËÉåÊôØ‰∏ä */
.control-panel,
.result-panel {
  flex: 1;
  padding: 0;
  margin: 0;
  background-color: transparent;
  border: none;
  box-shadow: none;
  border-radius: 0;
}

/* ÊéßÂà∂Èù¢ÊùøÁâπÂÆöÊ†∑Âºè */
.control-panel {
  max-width: 30vw; /* ‰ªé480pxÊîπ‰∏∫380pxÔºåÊõ¥Á™Ñ */
  flex-shrink: 0;
  /* ÈáçÊñ∞ÂÆö‰πâÊâÄÊúâË¢´Ë¶ÜÁõñÁöÑÂ±ûÊÄß */
  border: 1px solid rgba(192, 192, 192, 0.3) !important; /* Êõ¥ÁªÜÊõ¥ÈÄèÊòéÁöÑÈì∂Ëâ≤ËæπÊ°Ü */
  border-radius: 6px !important; /* Á®çÂæÆÂáèÂ∞èÂúÜËßí */
  background: #ffffff !important; /* Á∫ØÁôΩËÉåÊôØÔºåÂéªÊéâÊ∏êÂèò */
  box-shadow: none !important; /* ÂéªÊéâÊâÄÊúâÈò¥ÂΩ± */
  padding: 1.5rem !important; /* ÂÜÖËæπË∑ù */
  position: relative; /* ‰∏∫‰º™ÂÖÉÁ¥†ÂÆö‰Ωç */
}

/* ÂéªÊéâÈ°∂ÈÉ®Ë£ÖÈ•∞Êù° */
.control-panel::before {
  display: none; /* ÈöêËóèÈ°∂ÈÉ®Ë£ÖÈ•∞Êù° */
}

/* ÁªìÊûúÈù¢ÊùøÁâπÂÆöÊ†∑Âºè */
.result-panel {
  max-width: 520px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
}

/* Êñ∞Â¢ûÔºö‰ø°ÊÅØÊ®°ÂùóÊ†∑Âºè */
.info-panel {
  margin-top: 1rem;
  margin-left: -2rem; /* Ëøõ‰∏ÄÊ≠•ÂêëÂ∑¶Êâ©Â±ïÔºåËÆ©‰ø°ÊÅØÊ®°ÂùóÊõ¥Èù†Â∑¶ */
  padding: 1rem;
  background-color: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  font-size: 0.8rem; /* ÂáèÂ∞èÂ≠ó‰ΩìÂ§ßÂ∞è */
  line-height: 1.4; /* Ë∞ÉÊï¥Ë°åÈ´ò */
  width: calc(100% + 4rem); /* Ëøõ‰∏ÄÊ≠•Â¢ûÂä†ÂÆΩÂ∫¶ÔºåÂêëÂ∑¶Êâ©Â±ï */
}

.info-tags {
  margin-bottom: 0.75rem;
  line-height: 1.6; /* Â¢ûÂä†Ê†áÁ≠æË°åÈ´òÔºå‰æø‰∫éÊç¢Ë°å */
}

.tag {
  color: #495057;
  font-weight: 500;
  display: inline-block; /* ËÆ©Ê†áÁ≠æÂèØ‰ª•Êç¢Ë°å */
  margin-bottom: 0.2rem; /* Ê†áÁ≠æÂ∫ïÈÉ®Èó¥Ë∑ù */
}

.tag-separator {
  color: #6c757d;
  margin: 0 0.3rem; /* ÂáèÂ∞ëÂàÜÈöîÁ¨¶Èó¥Ë∑ù */
}

.info-description {
  color: #6c757d;
  margin-bottom: 0.75rem;
  font-style: italic;
}

.info-template {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.template-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.template-label {
  color: #495057;
  font-weight: 500;
}

.template-value {
  color: #6c757d;
  font-family: monospace;
}

/* ÊéßÂà∂Èù¢ÊùøÊ†∑Âºè */
.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #e4e7ed;
}

.panel-title {
  font-size: 1.1rem;
  font-weight: 600;
  color: #303133;
  margin: 0;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.format-selector {
  display: flex;
  justify-content: center;
}

.upgrade-btn {
  width: 100%;
  font-weight: bold;
  background-color: #e6a23c;
  border-color: #e6a23c;
}

.upgrade-btn:hover {
  background-color: #cf9236;
  border-color: #cf9236;
}

.control-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.control-item .label {
  font-weight: 500;
  color: #606266;
}

.image-control {
  display: flex;
  flex-direction: column;
  margin-bottom: 1.5rem;
}

.image-control .image-size {
  font-size: 0.8rem;
  color: #909399;
  margin-bottom: 0.75rem;
}

.upload-action-btn {
  width: 100%;
  background-color: #f56c6c !important;
  border-color: #f56c6c !important;
}

.upload-action-btn:hover {
  background-color: #f78989 !important;
  border-color: #f78989 !important;
}

.color-control {
  margin-bottom: 1.5rem;
}

.color-picker-wrapper {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.5rem;
  margin-left: 1rem;
}

.color-value {
  font-family: monospace;
  font-size: 0.9rem;
  color: #606266;
}

.background-control {
  margin-bottom: 1.5rem;
}

.upload-section {
  margin-bottom: 2rem;
}

.upload-label {
  display: block;
  font-size: 1rem;
  font-weight: 500;
  color: #606266;
  margin-bottom: 0.75rem;
}

.image-uploader {
  margin-bottom: 1rem;
}

.preview-image {
  max-height: 160px;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  display: none;
}

.render-section {
  margin-bottom: 2rem;
}

.render-button {
  width: 100%;
  height: 48px;
  font-size: 16px;
  font-weight: bold;
}

.render-hint {
  font-size: 0.875rem;
  color: #909399;
  margin-top: 0.5rem;
  text-align: center;
}

.alert-content {
  margin: 0;
  font-size: 0.875rem;
  line-height: 1.5;
}

.vertical-divider {
  width: 1px;
  background-color: #e4e7ed;
  margin: 0;
  align-self: stretch;
  opacity: 0.6;
}



.canvas-container {
  width: 95%;
}

canvas {
  width: 100%;
  height: auto;
}

/* ÂìçÂ∫îÂºèËÆæËÆ° */
@media (max-width: 768px) {
  .page-container :deep(.header) {
    width: 100% !important;
    position: fixed !important;
    top: 0 !important;
  }
  
  .mockup-tool-container {
    padding-top: 5rem; /* ÁßªÂä®Á´ØÂáèÂ∞ëÈ°∂ÈÉ®Èó¥Ë∑ù */
  }
  
  .header-section {
    padding: 0 3rem; /* ÁßªÂä®Á´ØÂáèÂ∞ëÂ∑¶Âè≥ËæπË∑ù */
  }
  
  .function-section {
    padding: 0 3rem 2rem 3rem; /* ÁßªÂä®Á´ØÂáèÂ∞ëÂ∑¶Âè≥ËæπË∑ù */
    flex-direction: column;
    gap: 2rem;
  }
  
  .unified-content-container {
    flex-direction: column;
    padding: 1.5rem;
  }
  
  .vertical-divider {
    width: 100%;
    height: 1px;
    margin: 1.5rem 0;
  }
  
  .control-panel,
  .result-panel {
    max-width: 100%;
  }
}
</style>
